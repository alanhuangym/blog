---
title: 推荐系统3
date: 2017-08-30 09:12:35
tags:
- recommendationsystem
categories:
- recommendationsystem
---

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

### 现在使用协同过滤方法

**数据概况**

“持有过.csv”

目前只调用了2016年年度数据。

统计用户在该年度中，曾经持仓过哪些产品，用于分析用户投资偏好。

数据约190w条。

每一条数据分别代表一位用户一个产品在该年度的平均持有数量和金额。

通过初步分析，得知，数据共包含125w位用户。

**子代码情况**

其中约有<font color="red">96w</font>的用户在该年度内只购买过<font color="red">一款产品</font>（不计购买次数）

<font color="red">29w</font>用户购买过两款产品以上。

平均每位用户购买**1.52**款子产品

**母代码情况**

其中约有<font color="red">121w</font>的用户在该年度内只购买过<font color="red">一款产品</font>（不计购买次数）

只有<font color="red">4w</font>用户购买过两款产品以上。

平均每位用户购买**1.03**款母产品



**初步构建**

为了简化该问题，所以首先只考虑用户曾经持仓的产品，忽略<font color="red">**购买次数、购买金额、购买日期、卖出**</font>等数据。建立一个用户-产品的矩阵（如下）。

| 表格   | 产品1  | 产品2  | 产品3  | 产品4  | 产品5  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 用户1  | 0    | 0    | 0    | 0    | 1    |
| 用户2  | 0    | 1    | 0    | 1    | 0    |
| 用户3  | 0    | 0    | 1    | 1    | 0    |
| 用户4  | 0    | 0    | 0    | 0    | 1    |
| 用户5  | 0    | 1    | 0    | 1    | 0    |

1则表示在该年度（目前只统计了2016年年度数据），该用户曾经持仓过该产品。

0则表示没有。

通过建立这个矩阵之后，计算不同用户之间的相似度。



相似度计算使用[Jaccard Similarity](https://en.wikipedia.org/wiki/Jaccard_index)

$$similarity=\frac{USER1 \cap USER2}{USER1 \cup USER2}$$

（问题：是否需要在分子分母上加1）

即是计算两个用户之间购买了相同产品的数量，再除以两个用户共购买了多少款产品，即得到相似度。

<font color="red">问题：用母代码还是子代码？</font>

但是由于之前描述的数据概况，大部分用户都只购买了一款产品，所以计算相似度时很大概率得到的结果是1和0。（完全相同和完全不相同）



**针对只购买了一款产品的用户**

所以为了实现协同过滤的效果，我们需要先挑选出**购买过两款产品或以上**的用户出来，然后再根据这些用户与其他用户进行重合，进行推荐。

首先，根据统计一共有125款母代码产品。

制作一份字典，遍历一遍记录，然后对于购买了两款产品以上的用户加入到字典里，索引是购买产品的产品代码。

然后对于每一个只购买了一款产品的用户就可以到这份字典去索引，根据已经购买了的产品代码，可以得到与其相似的用户群，然后根据用户群进行推荐。

这样，计算量可以离线完成，对于大部分的用户（只买过一款产品的），推荐系统的结果可以直接存取，快捷。

**对于购买了两款产品或以上的用户**

可以直接使用Jaccard Similarity 的计算方法，计算两位用户之间的相似度。

设定一个阈值（threshold），当两位用户相似度超过这个阈值之后（去除相似度1.0的用户，以为完全相同没有推荐的意义），则认定这两位用户为相似用户。然后根据相似用户的其他喜好，进行推荐。



### 后期完善

**1.使用时间字段**

根据购买时间与现在时间的差值，赋予用户一个权重，标识这个用户近期对该产品的偏好程度。

可以参考ES中的[decay_function](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-function-score-query.html#function-decay)。

![](https://www.elastic.co/guide/en/elasticsearch/reference/5.5/images/decay_2d.png)根据时间差，套入不同的计算公式中，得出一个权重。



**2.购买数量与金额**

由于每个客户的购买金额和购买次数是不一样的。在初步构建的当中，我们忽略了购买的金额和次数，均算作1。所以我们现在需要将购买金额和次数考虑进去。

想法是：

$$金额权重=\frac{购买总金额}{该产品的最低购买金额}$$

由于每个产品的规模大小都不一样，所以不能单纯以购买金额去衡量用户与产品之间的关系。所以我们使用到客户购买的总金额除以最低购买门槛金额，得到一个倍数，然后再辅以一个函数，达到实现权重的目的。

其次，由于某一个客户可能会购买一款母代码的多款子产品，所以购买次数也会反应该用户的投资偏好，我们可以再设定一个函数，去控制该权重。



**3.结合**

根据上述两个字段的影响，每个用户-产品矩阵的内容可以为上述两个字段的权重相加相乘，然后就能计算更加准确的用户相似度。



**4.已找出相似用户后的推荐想法**

如果已经找出了相似的用户，那么就以这群用户对产品的购买次数进行统计，给出一个排名，然后相应地推荐排名第一的产品和后续产品中，客户尚未购买过的产品。